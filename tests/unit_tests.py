import h5py
import typing
import tempfile
import pathlib
import pytest
import numpy as np
from context import ball_trajectories as bt


# configuration of the stamped_trajectory fixture
_START_POSITION = (1.0, 2.0, 1.0)
_END_POSITION = (3.0, 4.0, 1.0)
_VELOCITY = 0.5
_SAMPLING_RATE = 10000  # microseconds

# configuration for working_directory fixture
_NB_JSONS = 3
_JSON_FILES = ["{}.json".format(i) for i in range(_NB_JSONS)]
_JSON_GROUP = "json"
_NB_TENNICAMS = 2
_TENNICAM_FILES = ["tennicam_{}".format(i) for i in range(_NB_TENNICAMS)]
_TENNICAM_GROUP = "tennicam"
_NB_BALL_ROBOTS = 2
_BALL_ROBOT_FILES = ["o80_robot_ball_{}".format(i) for i in range(_NB_TENNICAMS)]
_BALL_ROBOT_GROUP = "o80_robot_ball"
_HDF5 = "test.hdf5"


@pytest.fixture
def duration_trajectory() -> bt.DurationTrajectory:
    """
    Generate a line trajectory from start to end position
    """
    return bt.velocity_line_trajectory(
        _START_POSITION, _END_POSITION, _VELOCITY, float(_SAMPLING_RATE * 1e-6)
    )


@pytest.fixture
def json_trajectory(duration_trajectory: bt.DurationTrajectory) -> str:
    """
    Convert the duration trajectory to a json string representation,
    as supported by bt.RecordedBallTrajectories.add_json_trajectories.
    """
    positions = duration_trajectory[1]
    velocities = duration_trajectory[2]
    entries = np.concatenate((positions, velocities), axis=1)
    entries = list([list(entries[i, :]) for i in range(entries.shape[0])])
    d = {"ob": entries}
    return repr(d)


@pytest.fixture
def tennicam_trajectory(duration_trajectory: bt.DurationTrajectory) -> str:
    """
    create the string representation of a ball trajectory
    in tennicam format.
    """

    size = len(duration_trajectory[0])
    ball_ids = [i for i in range(size)]
    stamped_trajectory = bt.to_stamped_trajectory(duration_trajectory)
    time_stamps = stamped_trajectory[0]
    positions = list(duration_trajectory[1])
    velocities = list(duration_trajectory[2])
    entries = [
        (ball_id, time_stamp * 1e3, list(position), list(velocity))
        for ball_id, time_stamp, position, velocity in zip(
            ball_ids, time_stamps, positions, velocities
        )
    ]
    return "\n".join([repr(e) for e in entries])


@pytest.fixture
def ball_robot_trajectory(duration_trajectory: bt.DurationTrajectory) -> str:
    """
    create the string representation of a ball / robot trajectory
    in the format of files generated by o80_pam/o80_robot_ball_logger.
    """

    size = len(duration_trajectory[0])
    ball_ids = [i for i in range(size)]
    stamped_trajectory = bt.to_stamped_trajectory(duration_trajectory)
    time_stamps = list(stamped_trajectory[0])
    ball_positions = list([list(d) for d in duration_trajectory[1]])
    ball_velocities = list([list(d) for d in duration_trajectory[1]])
    robot_positions = [bp + [0.0] for bp in ball_positions]
    robot_velocities = [bv + [0.0] for bv in ball_velocities]
    entries = []
    for index in range(len(ball_ids)):
        ball_id = ball_ids[index]
        time_stamp = time_stamps[index] * 1e3
        ball_position = list(ball_positions[index])
        ball_velocity = list(ball_velocities[index])
        robot_position = list(robot_positions[index])
        robot_velocity = list(robot_velocities[index])
        entries.append(
            (
                (ball_id, time_stamp, ball_position, ball_velocity),
                (time_stamp, robot_position, robot_velocity),
            )
        )
    return "\n".join([repr(e) for e in entries])


@pytest.fixture
def working_directory(
    tmp_path: pathlib.Path,
    json_trajectory: str,
    tennicam_trajectory: str,
    ball_robot_trajectory: str,
) -> pathlib.Path:
    """
    Generate some json and tennicam files, as well as an
    empty hdf5 file, in a tmp directory
    """

    jsons = [tmp_path / jf for jf in _JSON_FILES]

    tennicams = [tmp_path / tf for tf in _TENNICAM_FILES]

    ball_robots = [tmp_path / br for br in _BALL_ROBOT_FILES]

    for jf in jsons:
        with open(jf, "w") as f:
            f.write(json_trajectory)

    for tf in tennicams:
        with open(tf, "w") as f:
            f.write(tennicam_trajectory)

    for br in ball_robots:
        with open(br, "w") as f:
            f.write(ball_robot_trajectory)

    hdf5_file = tmp_path / _HDF5
    with h5py.File(hdf5_file, "w"):
        pass

    return tmp_path


@pytest.fixture
def loaded_hdf5(working_directory) -> pathlib.Path:
    """
    Add content to the hdf5 file present in the
    working directory, and returns the absolute path
    to this file.
    """

    hdf5_file = working_directory / _HDF5

    with bt.MutableRecordedBallTrajectories(path=hdf5_file) as rbt:
        rbt.add_json_trajectories(_JSON_GROUP, working_directory, _SAMPLING_RATE * 1e6)
        rbt.add_tennicam_trajectories(_TENNICAM_GROUP, working_directory)
        rbt.add_ball_robot_trajectories(_BALL_ROBOT_GROUP, working_directory)

    return hdf5_file


def test_rm_group(loaded_hdf5) -> None:
    """
    Test the RecordedBallTrajectories.rm_group
    method.
    """

    path = loaded_hdf5
    with bt.MutableRecordedBallTrajectories(path) as rbt:
        assert _JSON_GROUP in rbt.get_groups()
        rbt.rm_group(_JSON_GROUP)
        assert _JSON_GROUP not in rbt.get_groups()

    with bt.MutableRecordedBallTrajectories(path) as rbt:
        assert _JSON_GROUP not in rbt.get_groups()


def test_overwrite(loaded_hdf5) -> None:
    """
    Test the MutableRecordedBallTrajectories.overwrite
    method.
    """
    stamps = np.array([10] * 5)
    positions = np.array([np.array([2] * 3)] * 5)
    path = loaded_hdf5

    with bt.MutableRecordedBallTrajectories(path) as rbt:
        rbt.overwrite(_JSON_GROUP, 1, (stamps, positions))

    with bt.RecordedBallTrajectories(path) as rbt:
        stamped_trajectory = rbt.get_stamped_trajectory(_JSON_GROUP, 1)
        restamps = stamped_trajectory[0]
        repositions = stamped_trajectory[1]
        assert np.array_equal(stamps, restamps)
        for line in range(positions.shape[0]):
            p1 = positions[line, :]
            p2 = repositions[line, :]
            np.testing.assert_almost_equal(p1, p2)


def test_conversions(duration_trajectory) -> None:
    """
    Test the conversions from state trajectory to
    stamped trajectory, and vice-versa
    """

    stamped_trajectory = bt.to_stamped_trajectory(duration_trajectory)
    reduration_trajectory = bt.to_duration_trajectory(stamped_trajectory)

    # durations
    assert np.array_equal(duration_trajectory[0][:-1], reduration_trajectory[0])

    # positions
    for line in range(duration_trajectory[1][1:, :].shape[0]):
        p1 = duration_trajectory[1][line, :]
        p2 = reduration_trajectory[1][line, :]
        np.testing.assert_almost_equal(p1, p2)

    # velocities
    for line in range(duration_trajectory[2][1:, :].shape[0]):
        v1 = duration_trajectory[2][line, :]
        v2 = reduration_trajectory[2][line, :]
        np.testing.assert_almost_equal(v1, v2, decimal=3)


@pytest.mark.parametrize("formatting", [_JSON_GROUP, _TENNICAM_GROUP])
def test_add_trajectories(
    working_directory: pathlib.Path,
    duration_trajectory: bt.DurationTrajectory,
    formatting: str,
):
    """
    Test a hdf5 file can be updated via an instance of RecordedBallTrajectories
    with trajectories stored in json files or tennicam files or o80_robot_ball files.
    """

    stamped_trajectory = bt.to_stamped_trajectory(duration_trajectory)
    ref_time_stamps = stamped_trajectory[0]
    ref_trajectory_size = len(ref_time_stamps)

    hdf5_path = working_directory / _HDF5

    group_name = formatting

    with bt.MutableRecordedBallTrajectories(path=hdf5_path) as rbt:
        if formatting == _JSON_GROUP:
            nb_added = rbt.add_json_trajectories(
                group_name, working_directory, _SAMPLING_RATE
            )
            expected_size = _NB_JSONS
        elif formatting == _BALL_ROBOT_GROUP:
            nb_added = rbt.add_ball_robot_trajectories(group_name, working_directory)
            expected_size = _NB_BALL_ROBOTS
        else:
            nb_added = rbt.add_tennicam_trajectories(group_name, working_directory)
            expected_size = _NB_TENNICAMS

    assert nb_added == expected_size

    with bt.RecordedBallTrajectories(path=hdf5_path) as rbt:
        assert group_name in rbt.get_groups()
        assert len(rbt.get_indexes(group_name)) == expected_size
        trajectory: StampedTrajectory = rbt.get_stamped_trajectory(group_name, 0)
        time_stamps = trajectory[0]
        positions = trajectory[1]
        assert time_stamps.shape == (ref_trajectory_size,)
        assert positions.shape == (ref_trajectory_size, 3) or positions.shape == (
            ref_trajectory_size,
            7,
        )
        assert list(time_stamps) == pytest.approx(list(ref_time_stamps), abs=1)
        np.testing.assert_almost_equal(trajectory[1], stamped_trajectory[1])


@pytest.mark.parametrize(
    "formatting", [_JSON_GROUP, _TENNICAM_GROUP, _BALL_ROBOT_GROUP]
)
def test_ball_trajectories(
    loaded_hdf5: pathlib.Path,
    duration_trajectory: bt.DurationTrajectory,
    formatting: str,
):
    """
    Test the API of BallTrajectories
    """

    if formatting == _JSON_GROUP:
        ball_trajectories = bt.BallTrajectories(_JSON_GROUP, loaded_hdf5)
        expected_size = _NB_JSONS
    elif formatting == _BALL_ROBOT_GROUP:
        ball_trajectories = bt.BallTrajectories(_BALL_ROBOT_GROUP, loaded_hdf5)
        expected_size = _NB_BALL_ROBOTS
    else:
        ball_trajectories = bt.BallTrajectories(_TENNICAM_GROUP, loaded_hdf5)
        expected_size = _NB_TENNICAMS

    assert len(ball_trajectories.get_all_trajectories()) == expected_size
    assert ball_trajectories.size() == expected_size
    assert (
        len(ball_trajectories.get_different_random_trajectories(expected_size))
        == expected_size
    )
    assert len(
        ball_trajectories.get_different_random_trajectories(expected_size - 1)
    ) == (expected_size - 1)

    stamped_trajectory = ball_trajectories.get_trajectory(0)
    time_stamps = stamped_trajectory[0]
    positions = stamped_trajectory[1]
    assert time_stamps.shape == (len(duration_trajectory[0]),)
    assert positions.shape == (len(duration_trajectory[0]), 3) or positions.shape == (
        len(duration_trajectory[0]),
        7,
    )


def test_ball_undetected_fix():
    """
    Testing BallTrajectories manages correctly steps with
    undetected ball
    """

    robot_position = (0.0,) * 4
    robot_velocity = (0.0,) * 4
    ball_velocity = (0.1,) * 4
    unknown = (-100.0,) * 3

    entries = []

    entries.append(((-1, 1e3, unknown, unknown), (1e3, robot_position, robot_velocity)))
    entries.append(((-1, 2e3, unknown, unknown), (2e3, robot_position, robot_velocity)))
    entries.append(((-1, 3e3, unknown, unknown), (3e3, robot_position, robot_velocity)))
    entries.append(((-1, 4e3, unknown, unknown), (4e3, robot_position, robot_velocity)))
    entries.append(
        (
            (1, 4e3, (0.0, 0.9, 0.0), ball_velocity),
            (4e3, robot_position, robot_velocity),
        )
    )
    entries.append(
        (
            (1, 5e3, (0.0, 1.0, 0.0), ball_velocity),
            (5e3, robot_position, robot_velocity),
        )
    )
    entries.append(((-1, 6e3, unknown, unknown), (6e3, robot_position, robot_velocity)))
    entries.append(((-1, 7e3, unknown, unknown), (7e3, robot_position, robot_velocity)))
    entries.append(((-1, 8e3, unknown, unknown), (8e3, robot_position, robot_velocity)))
    entries.append(((-1, 9e3, unknown, unknown), (9e3, robot_position, robot_velocity)))
    entries.append(
        (
            (1, 10e3, (0.0, 1.5, 0.0), ball_velocity),
            (10e3, robot_position, robot_velocity),
        )
    )
    entries.append(
        ((-1, 11e3, unknown, unknown), (11e3, robot_position, robot_velocity))
    )
    entries.append(
        ((-1, 12e3, unknown, unknown), (12e3, robot_position, robot_velocity))
    )
    entries.append(
        ((-1, 13e3, unknown, unknown), (13e3, robot_position, robot_velocity))
    )
    entries.append(
        ((-1, 14e3, unknown, unknown), (14e3, robot_position, robot_velocity))
    )
    entries.append(
        (
            (1, 15e3, (0.0, 1.5, 2.0), ball_velocity),
            (15e3, robot_position, robot_velocity),
        )
    )
    entries.append(
        (
            (1, 16e3, (0.0, 1.5, 2.2), ball_velocity),
            (16e3, robot_position, robot_velocity),
        )
    )
    entries.append(
        (
            (1, 17e3, (0.0, 1.5, 2.4), ball_velocity),
            (17e3, robot_position, robot_velocity),
        )
    )
    entries.append(
        ((-1, 18e3, unknown, unknown), (18e3, robot_position, robot_velocity))
    )
    entries.append(
        ((-1, 19e3, unknown, unknown), (19e3, robot_position, robot_velocity))
    )

    file_content = "\n".join([repr(e) for e in entries])

    with tempfile.TemporaryDirectory() as tmp_dir_:

        tmp_dir = pathlib.Path(tmp_dir_)

        hdf5file = tmp_dir / "records.hdf5"
        with h5py.File(hdf5file, "w"):
            pass

        filename = "o80_robot_ball_001"
        filepath = tmp_dir / filename
        with open(filepath, "w") as f:
            f.write(file_content)

        group_name = "robot_ball"

        records = bt.MutableRecordedBallTrajectories(hdf5file)
        nb_records = records.add_ball_robot_trajectories(group_name, tmp_dir)
        assert nb_records == 1

        trajectory = records.get_stamped_trajectory(group_name, 0)
        # -6: first 4 and last 2 entries of entries are undetected ball
        # and should have been trimmed
        assert trajectory[1].shape == (len(entries) - 6, 7)

        def assert_almost_equal(t1: typing.Iterable, t2: typing.Iterable, thres=1e-4):
            for v1, v2 in zip(t1, t2):
                v1 == pytest.approx(v2, thres)

        assert_almost_equal(trajectory[1][3], (0.0, 1.2, 0.0, 0.0, 0.0, 0.0, 0.0))
        assert_almost_equal(trajectory[1][9], (0.0, 1.5, 1.2, 0.0, 0.0, 0.0, 0.0))
